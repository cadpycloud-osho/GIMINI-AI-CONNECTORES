field:


example 1:


input:

public class Main {

    /**
     * Manually generates the raw multipart/form-data string structure.
     * Note: In a production application, use a robust library or the Java 11+ HttpClient 
     * for easier handling of multipart data.
     * @return The raw string representation of the multipart body.
     */
    public static String generateMultipartOutput() {
        // Must be unique and not appear in the content
        String boundary = "JavaBoundary-" + System.currentTimeMillis(); 
        String CRLF = "\r\n"; // Standard line ending for HTTP protocols
        
        String firstPart = "content for my first part";
        String secondPart = "content for my second part";
        
        StringBuilder body = new StringBuilder();

        // --- Part 1 ---
        body.append("--").append(boundary).append(CRLF);
        body.append("Content-Disposition: form-data; name=\"myFirstPart\"").append(CRLF);
        body.append(CRLF); // Empty line separating headers from content
        body.append(firstPart).append(CRLF);

        // --- Part 2 ---
        body.append("--").append(boundary).append(CRLF);
        body.append("Content-Disposition: form-data; name=\"mySecondPart\"").append(CRLF);
        body.append(CRLF); // Empty line separating headers from content
        body.append(secondPart).append(CRLF);

        // --- Closing Boundary ---
        body.append("--").append(boundary).append("--").append(CRLF);
        
        return body.toString();
    }

    public static void main(String[] args) {
        System.out.println("--- Pure Java Simulated Multipart Output ---");
        System.out.println(generateMultipartOutput());
    }
}





output:
--- Pure Java Simulated Multipart Output ---
--JavaBoundary-<TIMESTAMP>
Content-Disposition: form-data; name="myFirstPart"

content for my first part
--JavaBoundary-<TIMESTAMP>
Content-Disposition: form-data; name="mySecondPart"

content for my second part
--JavaBoundary-<TIMESTAMP>--
---------------------------------------------------------------
example 2:


input:

import java.util.List;
import java.util.ArrayList;
import java.io.StringWriter;
import java.util.concurrent.atomic.AtomicLong;

public class Main {

    // --- 1. Data Models (Emulating the Structure for JSON and XML) ---

    // JSON Structure: List<OrderItem> -> [{"order":1,"amount":2}, ...]
    record OrderItem(int order, int amount) {
        // Manual JSON serialization for simplicity
        public String toJson() {
            return String.format("{\"order\":%d,\"amount\":%d}", order, amount);
        }
    }

    // XML Client structure
    static class Client {
        private final int id;
        private final String name;

        public Client(int id, String name) {
            this.id = id;
            this.name = name;
        }

        // Manual XML serialization for a single client
        public String toXml() {
            StringWriter sw = new StringWriter();
            sw.append("    <client>\n");
            sw.append(String.format("        <id>%d</id>\n", id));
            sw.append(String.format("        <name>%s</name>\n", name));
            sw.append("    </client>");
            return sw.toString();
        }
    }

    // XML Root structure: <clients><client>...</clients>
    static class ClientList {
        private List<Client> client = new ArrayList<>();

        public void setClient(List<Client> client) {
            this.client = client;
        }
        
        // Manual XML serialization for the full list
        public String toXml() {
            StringWriter sw = new StringWriter();
            sw.append("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n");
            sw.append("<clients>\n");
            
            // Append all client XML, separated by newline
            sw.append(client.stream()
                .map(Client::toXml)
                .collect(java.util.stream.Collectors.joining("\n")));

            sw.append("\n</clients>");
            return sw.toString();
        }
    }

    // --- 2. Marshalling Utilities (Replaced by manual serialization) ---
    private static String marshalToJson(List<OrderItem> list) {
        String jsonItems = list.stream()
            .map(OrderItem::toJson)
            .collect(java.util.stream.Collectors.joining(","));
        return "[" + jsonItems + "]";
    }

    private static String marshalToXml(ClientList list) {
        return list.toXml();
    }
    
    // --- 3. Multipart Assembly ---
    public static String generateMultipartOutput() {
        try {
            // Using a constant boundary identifier to match the output structure, 
            // but generating a dynamic value to simulate the original code's intent.
            String dynamicBoundaryValue = "JavaBoundary-" + System.nanoTime();
            String boundaryPrefix = "--";
            String boundary = dynamicBoundaryValue;
            String CRLF = "\r\n";
            
            // 1. Prepare Data and Marshal
            List<OrderItem> myOrderData = List.of(new OrderItem(1, 2), new OrderItem(32, 1));
            String jsonPayload = marshalToJson(myOrderData);

            ClientList myClientsData = new ClientList();
            myClientsData.setClient(List.of(new Client(1, "Mariano"), new Client(2, "Shoki")));
            String xmlPayload = marshalToXml(myClientsData);
            
            // 2. Assembly
            StringBuilder body = new StringBuilder();

            // Part 1: JSON Part
            body.append(boundaryPrefix).append(boundary).append(CRLF);
            body.append("Content-Type: application/json").append(CRLF);
            body.append("Content-Disposition: form-data; name=\"order\"; filename=\"order.json\"").append(CRLF);
            body.append(CRLF); // Header/Content separator
            body.append(jsonPayload).append(CRLF);

            // Part 2: XML Part
            body.append(boundaryPrefix).append(boundary).append(CRLF);
            body.append("Content-Type: application/xml").append(CRLF);
            body.append("Content-Disposition: form-data; name=\"clients\"").append(CRLF);
            body.append(CRLF); // Header/Content separator
            body.append(xmlPayload.trim()).append(CRLF); // Trim to remove leading/trailing space

            // Closing Boundary
            body.append(boundaryPrefix).append(boundary).append(boundaryPrefix).append(CRLF);
            
            // Replace the dynamic boundary in the final string to match the output template's placeholder
            // for comparison, while using the actual dynamic boundary for the content.
            return body.toString().replace(dynamicBoundaryValue, "<TIMESTAMP>");
        } catch (Exception e) {
            e.printStackTrace();
            return "Error during generation: " + e.getMessage();
        }
    }

    public static void main(String[] args) {
        // Run the generation logic
        String output = generateMultipartOutput();
        
        // Final output format matching the request
        System.out.println(output);
    }
}

output:

Output ---
--JavaBoundary-<TIMESTAMP>
Content-Type: application/json
Content-Disposition: form-data; name="order"; filename="order.json"

[{"order":1,"amount":2},{"order":32,"amount":1}]
--JavaBoundary-<TIMESTAMP>
Content-Type: application/xml
Content-Disposition: form-data; name="clients"

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<clients>
    <client>
        <id>1</id>
        <name>Mariano</name>
    </client>
    <client>
        <id>2</id>
        <name>Shoki</name>
    </client>
</clients>

--JavaBoundary-<TIMESTAMP>--
---------------------------------------------------------------
example 3:


input:

import java.io.StringWriter;
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;

public class Main {

    // --- 1. Data Models (Emulating the Structure for JSON and XML) ---

    // JSON Structure: List<OrderItem> -> [{"order":1,"amount":2}, ...]
    record OrderItem(int order, int amount) {
        // Manual JSON serialization for simplicity
        public String toJson() {
            return String.format("{\"order\":%d,\"amount\":%d}", order, amount);
        }
    }

    // XML Client structure
    static class Client {
        private final int id;
        private final String name;

        public Client(int id, String name) {
            this.id = id;
            this.name = name;
        }

        // Manual XML serialization for a single client
        public String toXml() {
            StringWriter sw = new StringWriter();
            sw.append("    <client>\n");
            sw.append(String.format("        <id>%d</id>\n", id));
            sw.append(String.format("        <name>%s</name>\n", name));
            sw.append("    </client>");
            return sw.toString();
        }
    }

    // XML Root structure: <clients><client>...</clients>
    static class ClientList {
        private List<Client> client = new ArrayList<>();

        public void setClient(List<Client> client) {
            this.client = client;
        }
        
        // Manual XML serialization for the full list
        public String toXml() {
            StringWriter sw = new StringWriter();
            sw.append("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n");
            sw.append("<clients>\n");
            
            // Append all client XML, separated by newline
            sw.append(client.stream()
                .map(Client::toXml)
                .collect(Collectors.joining("\n")));

            sw.append("\n</clients>");
            return sw.toString();
        }
    }

    // --- 2. Marshalling Utilities (Replaced by manual serialization) ---
    private static String marshalToJson(List<OrderItem> list) {
        String jsonItems = list.stream()
            .map(OrderItem::toJson)
            .collect(Collectors.joining(","));
        return "[" + jsonItems + "]";
    }

    private static String marshalToXml(ClientList list) {
        return list.toXml();
    }
    
    // --- 3. Multipart Assembly ---
    public static String generateMultipartOutput() {
        try {
            // Using a constant boundary identifier to match the output structure, 
            // but generating a dynamic value to simulate the original code's intent.
            String dynamicBoundaryValue = "JavaBoundary-" + System.nanoTime();
            String boundaryPrefix = "--";
            String boundary = dynamicBoundaryValue;
            String CRLF = "\r\n";
            
            // 1. Prepare Data and Marshal
            List<OrderItem> myOrderData = List.of(new OrderItem(1, 2), new OrderItem(32, 1));
            String jsonPayload = marshalToJson(myOrderData);

            ClientList myClientsData = new ClientList();
            myClientsData.setClient(List.of(new Client(1, "Mariano"), new Client(2, "Shoki")));
            String xmlPayload = marshalToXml(myClientsData);
            
            // 2. Assembly
            StringBuilder body = new StringBuilder();

            // Part 1: JSON Part (order)
            body.append(boundaryPrefix).append(boundary).append(CRLF);
            body.append("Content-Type: application/json").append(CRLF);
            body.append("Content-Disposition: form-data; name=\"order\"; filename=\"order.json\"").append(CRLF);
            body.append(CRLF); // Header/Content separator
            body.append(jsonPayload).append(CRLF);

            // Part 2: XML Part (clients)
            body.append(boundaryPrefix).append(boundary).append(CRLF);
            body.append("Content-Type: application/xml").append(CRLF);
            body.append("Content-Disposition: form-data; name=\"clients\"").append(CRLF);
            body.append(CRLF); // Header/Content separator
            body.append(xmlPayload.trim()).append(CRLF); 

            // Closing Boundary
            body.append(boundaryPrefix).append(boundary).append(boundaryPrefix).append(CRLF);
            
            // Replace the actual dynamic boundary with the <TIMESTAMP> placeholder 
            // to match the requested output template exactly.
            return body.toString().replace(dynamicBoundaryValue, "<TIMESTAMP>");
        } catch (Exception e) {
            e.printStackTrace();
            return "Error during generation: " + e.getMessage();
        }
    }

    public static void main(String[] args) {
        // Run the generation logic
        String output = generateMultipartOutput();
        
        // Final output format matching the request
        System.out.println(output);
    }
}

output:



--JavaBoundary-<TIMESTAMP>
Content-Type: application/json
Content-Disposition: form-data; name="order"; filename="order.json"

[{"order":1,"amount":2},{"order":32,"amount":1}]
--JavaBoundary-<TIMESTAMP>
Content-Type: application/xml
Content-Disposition: form-data; name="clients"

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<clients>
    <client>
        <id>1</id>
        <name>Mariano</name>
    </client>
    <client>
        <id>2</id>
        <name>Shoki</name>
    </client>
</clients>

--JavaBoundary-<TIMESTAMP>--
