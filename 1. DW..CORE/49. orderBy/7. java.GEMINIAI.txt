orderBy:


example 1:



input:

import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Arrays;
import java.util.List;
import java.util.Comparator;
import java.util.stream.Collectors;

class LetterItem {
    public String letter;
    public LetterItem(String letter) { this.letter = letter; }
    public String getLetter() { return letter; }
}

public class Main {
    public static void main(String[] args) throws Exception {
        // 1. Define the input list
        List<LetterItem> inputList = Arrays.asList(
            new LetterItem("e"),
            new LetterItem("d")
        );

        // 2. Apply orderBy($.letter) - Java: stream().sorted(Comparator.comparing(Item::getLetter))
        List<LetterItem> sortedList = inputList.stream()
            .sorted(Comparator.comparing(LetterItem::getLetter))
            .collect(Collectors.toList());

        // 3. Output the result
        ObjectMapper mapper = new ObjectMapper();
        String outputJson = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(sortedList);
        
        System.out.println(outputJson);
    }
}

output:

[
  {
    "letter" : "d"
  },
  {
    "letter" : "e"
  }
]



------------------------------------------------------------

example 2:



input:

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.util.Arrays;
import java.util.List;
import java.util.Comparator;
import java.util.Collections;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) throws Exception {
        // 1. Define the input list
        List<Integer> inputList = Arrays.asList(3, 8, 1);

        // 2. Apply orderBy $ and then [-1 to 0] (Java: stream().sorted(Comparator.reverseOrder()))
        // The most direct Java equivalent is to sort descendingly.
        List<Integer> sortedDescending = inputList.stream()
            .sorted(Comparator.reverseOrder())
            .collect(Collectors.toList());

        // 3. Assemble the final JSON object
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode outputObject = mapper.createObjectNode();
        outputObject.set("orderDescending", mapper.valueToTree(sortedDescending));

        // 4. Output the result
        String outputJson = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(outputObject);
        
        System.out.println(outputJson);
    }
}

output:

{
  "orderDescending" : [ 8, 3, 1 ]
}



------------------------------------------------------------

example 3:



input:


import java.util.Arrays;
import java.util.List;
import java.util.Comparator;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        // 1. Define the input list
        List<Integer> inputList = Arrays.asList(3, 2, 3);

        // 2. Apply orderBy $ (Java: stream().sorted())
        // Natural order for Integer is ascending.
        List<Integer> sortedList = inputList.stream()
            .sorted(Comparator.naturalOrder()) 
            .collect(Collectors.toList()); 
        
        // sortedList now contains: [2, 3, 3]

        // 3. Manually format the result into the required JSON array output
        String outputJson = formatListAsJsonArray(sortedList);
        
        System.out.println(outputJson);
    }
    
    /**
     * Helper method to manually format a List of Integers into a compact JSON array string.
     * This replaces the functionality of the Jackson ObjectMapper.
     */
    private static String formatListAsJsonArray(List<Integer> list) {
        return list.stream()
            // Convert each Integer to a String
            .map(String::valueOf)
            // Join them with commas, wrapped in brackets
            .collect(Collectors.joining(", ", "[", "]"));
    }
}
output:

[ 2, 3, 3 ]



------------------------------------------------------------


example 4:



input:

import java.util.Arrays;
import java.util.List;
import java.util.Comparator;
import java.util.stream.Collectors;
import java.util.Map;
import java.util.HashMap;

class Person {
    public String name;
    public int age;
    
    public Person(String name, int age) { 
        this.name = name; 
        this.age = age;
    }
    
    public int getAge() { return age; }
    
    // Helper method to convert the object to a standard Map for manual JSON serialization
    public Map<String, Object> toMap() {
        Map<String, Object> map = new HashMap<>();
        map.put("name", this.name);
        map.put("age", this.age);
        return map;
    }
}

public class Main {
    public static void main(String[] args) {
        // 1. Define the input list
        List<Person> inputList = Arrays.asList(
            new Person("Santiago", 42),
            new Person("Leandro", 29),
            new Person("Mariano", 35)
        );

        // 2. Apply orderBy (person) -> person.age (Ascending sort by age)
        List<Person> sortedList = inputList.stream()
            // Comparator.comparingInt is the efficient way to sort by a primitive int field
            .sorted(Comparator.comparingInt(Person::getAge))
            .collect(Collectors.toList());

        // 3. Manually construct the JSON output string
        String outputJson = formatListAsPrettyJson(sortedList);
        
        System.out.println(outputJson);
    }
    
    /**
     * Helper method to manually format a list of Person objects 
     * into the required pretty-printed JSON array structure.
     */
    private static String formatListAsPrettyJson(List<Person> list) {
        StringBuilder sb = new StringBuilder();
        sb.append("[\n");
        
        for (int i = 0; i < list.size(); i++) {
            Person person = list.get(i);
            
            // Start of object
            sb.append("  {\n");
            
            // Field 1: "name"
            sb.append("    \"name\" : \"").append(person.name).append("\",\n");
            
            // Field 2: "age"
            sb.append("    \"age\" : ").append(person.age).append("\n");
            
            // End of object
            sb.append("  }");
            
            // Add comma if not the last item
            if (i < list.size() - 1) {
                sb.append(",\n");
            } else {
                sb.append("\n");
            }
        }
        
        sb.append("]");
        return sb.toString();
    }
}
output:


[
  {
    "name" : "Leandro",
    "age" : 29
  },
  {
    "name" : "Mariano",
    "age" : 35
  },
  {
    "name" : "Santiago",
    "age" : 42
  }
]


------------------------------------------------------------



example 5:



input:

import java.time.ZonedDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Comparator;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        // 1. Define the input list (ZonedDateTime is used for ISO 8601 strings)
        List<ZonedDateTime> inputList = Arrays.asList(
            ZonedDateTime.parse("2020-10-01T23:57:59.017Z"),
            ZonedDateTime.parse("2022-12-22T12:12:12.011Z"),
            ZonedDateTime.parse("2020-10-01T12:40:10.012Z"),
            ZonedDateTime.parse("2020-10-01T23:57:59.021Z")
        );

        // 2. Apply orderBy -($ as Number {unit: "milliseconds"})
        // Java: stream().sorted(Comparator.reverseOrder()) sorts chronologically descending.
        List<ZonedDateTime> sortedList = inputList.stream()
            .sorted(Comparator.reverseOrder())
            .collect(Collectors.toList());
        
        // 3. Convert the sorted ZonedDateTime objects to their ISO 8601 string representation
        // and manually format the list into a pretty-printed JSON array.
        String outputJson = formatListAsPrettyJsonArray(sortedList);
        
        System.out.println(outputJson);
    }
    
    /**
     * Helper method to manually format a List of ZonedDateTime objects 
     * into a pretty-printed JSON array of strings.
     */
    private static String formatListAsPrettyJsonArray(List<ZonedDateTime> list) {
        // 1. Convert ZonedDateTime objects to their standard String representation
        List<String> stringList = list.stream()
            .map(ZonedDateTime::toString)
            .collect(Collectors.toList());

        // 2. Format into the desired pretty-printed JSON array
        StringBuilder sb = new StringBuilder();
        sb.append("[\n");
        
        for (int i = 0; i < stringList.size(); i++) {
            // Indent, wrap the ISO string in quotes
            sb.append("  \"").append(stringList.get(i)).append("\"");
            
            // Add comma if not the last item
            if (i < stringList.size() - 1) {
                sb.append(",\n");
            } else {
                sb.append("\n");
            }
        }
        
        sb.append("]");
        return sb.toString();
    }
}
output:

[
  "2022-12-22T12:12:12.011Z",
  "2020-10-01T23:57:59.021Z",
  "2020-10-01T23:57:59.017Z",
  "2020-10-01T12:40:10.012Z"
]



------------------------------------------------------------



example 6:



input:

import java.util.Arrays;
import java.util.List;
import java.util.Comparator;
import java.util.stream.Collectors;
import java.util.Map;
import java.util.HashMap;

// Using Map<String, Object> for the nested CDetail field instead of Jackson's ObjectNode
class Account {
    public String AccountNumber;
    public String NameOnAccount;
    public String Type;
    public Map<String, Object> CDetail; // Changed to standard Map

    public Account(String num, String name, String type, Map<String, Object> detail) {
        this.AccountNumber = num;
        this.NameOnAccount = name;
        this.Type = type;
        this.CDetail = detail;
    }
    public String getType() { return Type; }

    // Helper method to convert the object to a standard Map for manual JSON serialization
    public Map<String, Object> toMap() {
        Map<String, Object> map = new HashMap<>();
        map.put("AccountNumber", this.AccountNumber);
        map.put("NameOnAccount", this.NameOnAccount);
        map.put("Type", this.Type);
        map.put("CDetail", this.CDetail);
        return map;
    }
}

public class Main {
    public static void main(String[] args) {
        // Helper to create empty or filled CDetail object (using standard Map)
        Map<String, Object> detailOpen = new HashMap<>();
        detailOpen.put("Status", "Open");
        Map<String, Object> detailEmpty = new HashMap<>();

        // 1. Define the input list
        List<Account> myInput = Arrays.asList(
            new Account("987999321", "QA", "AAAA", detailOpen),
            new Account("12399978", "QA", "BBBB", detailEmpty),
            new Account("32199974", "QA", "CCCC", detailEmpty)
        );

        // 2. Apply (myInput orderBy $.Type)[-1 to 0] - Descending order by Type
        List<Account> sortedDescending = myInput.stream()
            // Comparator.reversed() provides descending order (CCCC, BBBB, AAAA)
            .sorted(Comparator.comparing(Account::getType).reversed())
            .collect(Collectors.toList());

        // 3. Manually construct the JSON output string
        String outputJson = formatListAsPrettyJson(sortedDescending);
        
        System.out.println(outputJson);
    }
    
    /**
     * Helper method to manually format a list of Account objects 
     * into the required pretty-printed JSON array structure.
     */
    private static String formatListAsPrettyJson(List<Account> list) {
        StringBuilder sb = new StringBuilder();
        sb.append("[\n");
        
        for (int i = 0; i < list.size(); i++) {
            Account account = list.get(i);
            
            sb.append("  {\n");
            
            // Format basic fields
            sb.append("    \"AccountNumber\" : \"").append(account.AccountNumber).append("\",\n");
            sb.append("    \"NameOnAccount\" : \"").append(account.NameOnAccount).append("\",\n");
            sb.append("    \"Type\" : \"").append(account.Type).append("\",\n");
            
            // Format CDetail object manually
            sb.append("    \"CDetail\" : ");
            if (account.CDetail.isEmpty()) {
                sb.append("{ }");
            } else {
                // If CDetail is not empty, it contains {"Status": "Open"}
                Map.Entry<String, Object> detailEntry = account.CDetail.entrySet().iterator().next();
                sb.append("{\n");
                sb.append("      \"").append(detailEntry.getKey()).append("\" : \"").append(detailEntry.getValue()).append("\"\n");
                sb.append("    }");
            }
            
            sb.append("\n"); // Newline after CDetail block
            
            // End of object
            sb.append("  }");
            
            // Add comma if not the last item
            if (i < list.size() - 1) {
                sb.append(",\n");
            } else {
                sb.append("\n");
            }
        }
        
        sb.append("]");
        return sb.toString();
    }
}
output:

[
  {
    "AccountNumber" : "32199974",
    "NameOnAccount" : "QA",
    "Type" : "CCCC",
    "CDetail" : { }
  },
  {
    "AccountNumber" : "12399978",
    "NameOnAccount" : "QA",
    "Type" : "BBBB",
    "CDetail" : { }
  },
  {
    "AccountNumber" : "987999321",
    "NameOnAccount" : "QA",
    "Type" : "AAAA",
    "CDetail" : {
      "Status" : "Open"
    }
  }
]



------------------------------------------------------------






















