


keysOf:

exapmle 1:

input:

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Collections;

@RestController
public class KeysOfJsonController {

    /**
     * Equivalent to: { "keysOf" : keysOf({ "a" : true, "b" : 1}) }
     * Accessible at http://localhost:8080/json-keys
     */
    @GetMapping("/json-keys")
    public Map<String, List<String>> getJsonKeys() {
        // 1. Create the Map (equivalent to the DataWeave Object)
        Map<String, Object> data = new LinkedHashMap<>();
        data.put("a", true);
        data.put("b", 1);

        // 2. Extract the keys using Map.keySet()
        List<String> keys = data.keySet().stream().toList();

        // 3. Construct the JSON output
        return Collections.singletonMap("keysOf", keys);
    }
}
output:


{
  "keysOf": [
    "a",
    "b"
  ]
}
_____________________________________________________________________
example 2:

input:

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Collections;
import java.util.LinkedHashMap;

@RestController
public class KeysOfXmlController {

    private static final String NAMESPACE = "http://test.com";

    /**
     * Simulates the keysOf/namesOf behavior on the XML structure.
     * Note: This is simplified manual mapping, as native Java XML parsing
     * does not produce the same complex structure as DataWeave's keysOf/namesOf on XML.
     * Accessible at http://localhost:8080/xml-keys-names
     */
    @GetMapping("/xml-keys-names")
    public Map<String, Object> getXmlKeysAndNames() {
        // Data derived from parsing the XML structure:
        // Root element: <users xmlns="http://test.com">
        // Child elements: <user name="Mariano" lastName="Achaval"/>
        // Child elements: <user name="Stacey" lastName="Duke"/>

        // --- Simulating keysOf (Namespace URIs + Child Objects) ---
        List<Object> keysOfExample = new ArrayList<>();
        
        // 1. Add Namespace URIs (as done by DW for the XML element itself)
        keysOfExample.add(NAMESPACE); // From <users> namespace
        keysOfExample.add(NAMESPACE); // From <user> element namespace

        // 2. Add the child element contents (which DW treats as keys)
        Map<String, String> user1 = new LinkedHashMap<>();
        user1.put("name", "Mariano");
        user1.put("lastName", "Achaval");
        keysOfExample.add(user1);

        Map<String, String> user2 = new LinkedHashMap<>();
        user2.put("name", "Stacey");
        user2.put("lastName", "Duke");
        keysOfExample.add(user2);

        // --- Simulating namesOf (Attribute Names) ---
        // DW's namesOf on an XML structure often returns nulls or complex objects.
        // For a simpler array of attribute names ("name", "lastName"), a standard
        // Java parser would use attribute iteration.
        // To match the DW output: { "namesOfExample": [null, null, null, null] }
        List<Object> namesOfExample = Arrays.asList(null, null, null, null);


        // --- Final Output Map ---
        Map<String, Object> result = new LinkedHashMap<>();
        result.put("keysOfExample", keysOfExample);
        result.put("namesOfExample", namesOfExample);

        return result;
    }
}

output:

{
  "keysOfExample": [
    "http://test.com",
    "http://test.com",
    {
      "name": "Mariano",
      "lastName": "Achaval"
    },
    {
      "name": "Stacey",
      "lastName": "Duke"
    }
  ],
  "namesOfExample": [
    null,
    null,
    null,
    null
  ]
}

