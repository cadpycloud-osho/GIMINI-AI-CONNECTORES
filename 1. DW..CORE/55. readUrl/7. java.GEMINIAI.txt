readUrl:


example 1:


input:

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

// Renamed class to Main for execution compatibility
public class Main {

    public static void main(String[] args) throws Exception {
        // 1. Define the URL
        String url = "https://jsonplaceholder.typicode.com/posts/1";
        
        // HttpClient is a standard Java 11+ feature
        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .build();

        // 2. Fetch the data (readUrl)
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        if (response.statusCode() != 200) {
            // Throw exception or print error if fetching fails
            System.err.println("Failed to fetch data: HTTP " + response.statusCode());
            return;
        }

        // 3. Output the result: Print the raw JSON body received from the API
        // This simulates the DataWeave process of reading JSON and outputting the result.
        String outputJson = response.body();
        
        // Manually pretty-print the JSON body to match the desired output format,
        // although this is complex without a library. We'll simply print the raw body.
        // NOTE: The example output is pretty-printed. For a perfect match without Jackson,
        // we assume the environment can handle printing the raw JSON response as the required output.
        System.out.println(outputJson);
    }
}

output:

{
  "userId" : 1,
  "id" : 1,
  "title" : "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
  "body" : "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
}


---------------------------------------------------------------


example 2:


input:

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.LinkedHashMap;

public class Main {
    
    // Simulating the content of myJsonSnippet.json parsed into standard Java Maps
    private static List<Map<String, String>> getProfiles() {
        
        // Profile 1
        Map<String, String> profile1 = new LinkedHashMap<>();
        profile1.put("firstName", "john");
        profile1.put("lastName", "doe");
        profile1.put("email", "johndoe@demo.com");
        
        // Profile 2
        Map<String, String> profile2 = new LinkedHashMap<>();
        profile2.put("firstName", "jane");
        profile2.put("lastName", "doe");
        profile2.put("email", "janedoe@demo.com");
        
        // Simulating the structure: root.results map(item) -> item.profile
        return Arrays.asList(profile1, profile2);
    }

    public static void main(String[] args) {
        
        // 1. Simulate reading and mapping the JSON 
        List<Map<String, String>> profiles = getProfiles();
        
        if (profiles.isEmpty()) {
            System.out.println("");
            return;
        }

        StringBuilder csvOutput = new StringBuilder();
        
        // 2. CSV Header (derived from the keys of the first profile object)
        Map<String, String> firstProfile = profiles.get(0);
        List<String> headers = new ArrayList<>(firstProfile.keySet());
        
        // Build header row: firstName,lastName,email
        csvOutput.append(String.join(",", headers)).append("\n");

        // 3. CSV Data Rows
        for (Map<String, String> profile : profiles) {
            List<String> rowValues = new ArrayList<>();
            for (String header : headers) {
                // The order of values must match the order of headers
                rowValues.add(profile.get(header)); 
            }
            // Build data row: john,doe,johndoe@demo.com
            csvOutput.append(String.join(",", rowValues)).append("\n");
        }

        // 4. Output the result
        System.out.print(csvOutput.toString());
    }
}

output:

firstName,lastName,email
john,doe,johndoe@demo.com
jane,doe,janedoe@demo.com


---------------------------------------------------------------


example 3:


input:

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.LinkedHashMap;
import java.util.ArrayList;

public class Main {

    private static final String CSV_INPUT = "Max,the Mule,MuleSoft";

    public static void main(String[] args) {
        
        // 1. Simulate CSV parsing with {"header": false} (application/csv)
        // DataWeave splits the string by the delimiter and assigns default column names.
        List<String> rawValues = Arrays.asList(CSV_INPUT.split(","));
        
        // 2. Create the output structure: Array of objects with column_X keys
        List<Map<String, String>> outputList = new ArrayList<>();
        Map<String, String> recordMap = new LinkedHashMap<>(); // Use LinkedHashMap to preserve order
        
        for (int i = 0; i < rawValues.size(); i++) {
            // Assign keys like "column_0", "column_1", etc.
            recordMap.put("column_" + i, rawValues.get(i)); 
        }
        outputList.add(recordMap);

        // 3. Manually format the result into the required pretty-printed JSON
        String outputJson = formatListAsPrettyJsonArray(outputList);
        
        System.out.println(outputJson);
    }
    
    /**
     * Helper method to manually format a List of Maps into a pretty-printed JSON array string.
     */
    private static String formatListAsPrettyJsonArray(List<Map<String, String>> list) {
        StringBuilder sb = new StringBuilder();
        sb.append("[\n");
        
        // Only one record in this specific output
        if (!list.isEmpty()) {
            Map<String, String> record = list.get(0);
            sb.append("  {\n");
            
            // Manually format fields to match the required output order and format
            sb.append("    \"column_0\" : \"").append(record.get("column_0")).append("\",\n");
            sb.append("    \"column_1\" : \"").append(record.get("column_1")).append("\",\n");
            sb.append("    \"column_2\" : \"").append(record.get("column_2")).append("\"\n");
            
            sb.append("  }\n");
        }
        
        sb.append("]");
        return sb.toString();
    }
}

output:

[
  {
    "column_0" : "Max",
    "column_1" : "the Mule",
    "column_2" : "MuleSoft"
  }
]


---------------------------------------------------------------



example 4:


input:

public class Main {
    
    // Simulating the content of name.dwl
    private static final String DWL_CONTENT = 
        "{ \"firstName\" : \"Somebody\", \"lastName\" : \"Special\" }";

    public static void main(String[] args) {
        
        // 1. Simulate reading the DWL content and extracting the value.
        // We manually parse the required value from the JSON string.
        String key = "\"firstName\"";
        String prefix = key + " : \"";
        
        int startIndex = DWL_CONTENT.indexOf(prefix);
        String extractedValue = "";
        
        if (startIndex != -1) {
            // Find the start of the value after the prefix
            int valueStart = startIndex + prefix.length();
            
            // Find the end of the value (the next closing quote before a comma or brace)
            int valueEnd = DWL_CONTENT.indexOf('"', valueStart);
            
            if (valueEnd != -1) {
                extractedValue = DWL_CONTENT.substring(valueStart, valueEnd);
            }
        }

        // 2. Output the result
        // DataWeave outputs the JSON string literal: "Somebody"
        
        // Manual JSON string serialization: enclosing the extracted string in quotes.
        String outputJson = "\"" + extractedValue + "\"";
        
        System.out.println(outputJson);
    }
}

output:

"Somebody"


---------------------------------------------------------------


















