minBy:



example 1:


input:

import java.util.Arrays;
import java.util.List;
import java.util.Comparator;
import java.util.Optional;

// Simple internal class to represent the JSON structure { "a" : value }
class Item {
    public int a;

    public Item(int a) {
        this.a = a;
    }
    
    // Getter required for Comparator.comparingInt
    public int getA() {
        return a;
    }
}

public class Main {

    /**
     * DataWeave equivalent logic: 
     * [ {a: 1}, {a: 2}, {a: 3} ] minBy $.a
     * Output: { "a" : 1 }
     */
    public static void main(String[] args) throws Exception {
        // 1. Define the input array of objects (List in Java)
        List<Item> inputList = Arrays.asList(
            new Item(1), // The minimum element
            new Item(2),
            new Item(3)
        );

        // 2. Apply the 'minBy' function (Java equivalent: stream().min(Comparator))
        // The comparator finds the Item with the smallest 'a'.
        Optional<Item> minItemOptional = inputList.stream()
            .min(Comparator.comparingInt(Item::getA));
            
        // 3. Extract the value and construct the resulting JSON object
        String outputJson;
        
        if (minItemOptional.isPresent()) {
            Item minItem = minItemOptional.get();
            // Manually construct the JSON string with pretty printing: { "a" : value }
            outputJson = String.format("{\n  \"a\" : %d\n}", minItem.getA());
        } else {
            // Handle empty list case (DataWeave min on empty array returns null)
            outputJson = "null";
        }
        
        System.out.println(outputJson);
    }
}


output:

{
  "a" : 1
}

------------------------------------------------------------------





example 2:


input:


import java.time.ZonedDateTime;
import java.time.LocalDate;
import java.time.OffsetTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Comparator;
import java.util.Optional;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.stream.Collectors;

public class Main {

    /**
     * DataWeave equivalent logic:
     * { myMinBy: {
     * byDateTime: min(dateTimeList),
     * ...
     * } }
     */
    public static void main(String[] args) throws Exception {
        // DataWeave source values (treated as ZonedDateTime in Java)
        ZonedDateTime myDateTime1 = ZonedDateTime.parse("2017-10-01T22:57:59-03:00");
        ZonedDateTime myDateTime2 = ZonedDateTime.parse("2018-10-01T23:57:59-03:00");
        
        // 1. Inputs for MinBy operations
        List<ZonedDateTime> dateTimeList = List.of(myDateTime1, myDateTime2);
        List<LocalDate> dateList = List.of(myDateTime1.toLocalDate(), myDateTime2.toLocalDate());
        // The time part preserves the offset for comparison
        List<OffsetTime> timeList = List.of(myDateTime1.toOffsetDateTime().toOffsetTime(), 
                                             myDateTime2.toOffsetDateTime().toOffsetTime());
        // [true, false, false, true]. Min of Booleans is 'false'.
        List<Boolean> booleanList = List.of(true, false, (0 > 1), (1 > 0)); 
        List<Object> emptyList = Collections.emptyList();

        // 2. Apply the 'min' function (Java equivalent: stream().min(Comparator.naturalOrder()))
        
        // Find the earliest DateTime (2017 is earlier)
        Optional<ZonedDateTime> minDateTime = dateTimeList.stream().min(Comparator.naturalOrder());

        // Find the earliest Date (2017 is earlier)
        Optional<LocalDate> minDate = dateList.stream().min(Comparator.naturalOrder());

        // Find the earliest Time (22:57:59 is earlier than 23:57:59)
        Optional<OffsetTime> minTime = timeList.stream().min(Comparator.naturalOrder());

        // Find the minimum Boolean (false < true)
        Optional<Boolean> minBoolean = booleanList.stream().min(Comparator.naturalOrder());

        // min() returns Optional.empty() for empty list.
        Optional<?> minEmpty = emptyList.stream().min(Comparator.comparing(o -> "")); // Fix generic issue by providing a comparator
        
        // --- 3. Assemble the final JSON object structure (using standard Map) ---
        Map<String, String> myMinByMap = new LinkedHashMap<>();
        
        // DataWeave formats time objects to ISO 8601 strings, Booleans to true/false, null for empty array.
        myMinByMap.put("byDateTime", minDateTime.map(ZonedDateTime::toString).orElse(null));
        myMinByMap.put("byDate", minDate.map(LocalDate::toString).orElse(null));
        myMinByMap.put("byTime", minTime.map(t -> t.format(DateTimeFormatter.ISO_OFFSET_TIME)).orElse(null));
        myMinByMap.put("aBoolean", minBoolean.map(Object::toString).orElse(null));
        myMinByMap.put("emptyArray", minEmpty.isPresent() ? minEmpty.get().toString() : null); 
        
        // Construct the inner JSON object string
        String innerJson = myMinByMap.entrySet().stream()
            .map(e -> {
                String key = e.getKey();
                String value = e.getValue();
                
                if (value == null) {
                    return String.format("    \"%s\":null", key);
                } else if (key.equals("aBoolean")) {
                    // Boolean values are unquoted
                    return String.format("    \"%s\":%s", key, value);
                } else {
                    // Time/Date values are quoted
                    return String.format("    \"%s\":\"%s\"", key, value);
                }
            })
            .collect(Collectors.joining(",\n"));

        // Construct the final output JSON string
        String outputJson = String.format("{\n  \"myMinBy\":{\n%s\n  }\n}", innerJson);
        
        // Clean up formatting to match the compact requested output (no spaces after colons)
        outputJson = outputJson.replace(" :", ":"); 
        
        System.out.println(outputJson);
    }
}


output:

{
  "myMinBy" : {
    "byDateTime" : "2017-10-01T22:57:59-03:00",
    "byDate" : "2017-10-01",
    "byTime" : "22:57:59-03:00",
    "aBoolean" : false,
    "emptyArray" : null
  }
}
