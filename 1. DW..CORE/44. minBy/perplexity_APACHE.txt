minBy:

example 1:


input:

import org.apache.camel.builder.RouteBuilder;
import java.util.*;

public class MinByRoute extends RouteBuilder {
    @Override
    public void configure() throws Exception {
        from("direct:minBy")
            .process(exchange -> {
                List<Map<String, Integer>> items = Arrays.asList(
                    Map.of("a", 1),
                    Map.of("a", 2),
                    Map.of("a", 3)
                );
                
                // Find min by 'a' field value
                Map<String, Integer> minItem = items.stream()
                    .min(Comparator.comparingInt(m -> m.get("a")))
                    .orElse(null);
                
                exchange.getIn().setBody(minItem);
            })
            .marshal().json(JsonLibrary.Jackson)
            .to("log:output?showAll=true");
    }
}


output:

{ "a": 1 }


----------------------------------------------------------

example 2:


input:

import org.apache.camel.builder.RouteBuilder;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class MinByTemporalRoute extends RouteBuilder {
    private static final DateTimeFormatter DT_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssXXX");
    
    @Override
    public void configure() throws Exception {
        from("direct:minByTemporal")
            .process(exchange -> {
                // Parse datetime strings
                ZonedDateTime dt1 = ZonedDateTime.parse("2017-10-01T22:57:59-03:00", DT_FORMAT);
                ZonedDateTime dt2 = ZonedDateTime.parse("2018-10-01T23:57:59-03:00", DT_FORMAT);
                
                Map<String, Object> myMinBy = new LinkedHashMap<>();
                
                // byDateTime: earliest datetime
                myMinBy.put("byDateTime", minTemporal(Arrays.asList(dt1, dt2), ZonedDateTime::compareTo));
                
                // byDate: earliest date
                LocalDate date1 = dt1.toLocalDate();
                LocalDate date2 = dt2.toLocalDate();
                myMinBy.put("byDate", minTemporal(Arrays.asList(date1, date2), LocalDate::compareTo));
                
                // byTime: earliest time
                OffsetTime time1 = dt1.toOffsetTime();
                OffsetTime time2 = dt2.toOffsetTime();
                myMinBy.put("byTime", minTemporal(Arrays.asList(time1, time2), OffsetTime::compareTo));
                
                // aBoolean: false < true
                myMinBy.put("aBoolean", Collections.min(Arrays.asList(true, false, false, true)));
                
                // emptyArray: null
                myMinBy.put("emptyArray", null);
                
                Map<String, Object> result = new LinkedHashMap<>();
                result.put("myMinBy", myMinBy);
                exchange.getIn().setBody(result);
            })
            .marshal().json(JsonLibrary.Jackson)
            .to("log:output?showAll=true");
    }
    
    @SuppressWarnings("unchecked")
    private <T> Object minTemporal(List<T> items, Comparator<T> comparator) {
        return items.isEmpty() ? null : items.stream()
            .min(comparator)
            .orElse(null);
    }
}


output:

{
  "myMinBy": {
    "byDateTime": "2017-10-01T22:57:59-03:00",
    "byDate": "2017-10-01",
    "byTime": "22:57:59-03:00",
    "aBoolean": false,
    "emptyArray": null
  }
}

