fromHex:




input:

package com.example.hexconverter;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.math.BigInteger;
import java.util.LinkedHashMap;
import java.util.Map;

@SpringBootApplication
public class HexConverterApplication {

    public static void main(String[] args) {
        SpringApplication.run(HexConverterApplication.class, args);
    }
}

@RestController
class HexConverterController {

    @GetMapping("/convert-hex")
    public Map<String, Object> convertHexStrings() {
        Map<String, Object> result = new LinkedHashMap<>();

        // a: fromHex("-1")
        result.put("a", fromHex("-1"));

        // b: fromHex("3e3aeb4ae1383562f4b82261d969f7ac94ca4000000000000000")
        String hexB = "3e3aeb4ae1383562f4b82261d969f7ac94ca4000000000000000";
        result.put("b", fromHex(hexB));

        // c: fromHex(0) -> treat as string "0"
        result.put("c", fromHex("0"));

        // d: fromHex(null)
        result.put("d", null);

        // e: fromHex("f")
        result.put("e", fromHex("f"));

        return result;
    }

    private Object fromHex(String hexStr) {
        if (hexStr == null) {
            return null;
        }
        hexStr = hexStr.trim();
        if (hexStr.isEmpty()) {
            return null;
        }

        try {
            boolean isNegative = false;
            if (hexStr.startsWith("-")) {
                isNegative = true;
                hexStr = hexStr.substring(1);
            }

            // Convert hex string to BigInteger
            BigInteger decimalValue = new BigInteger(hexStr, 16);

            if (isNegative) {
                decimalValue = decimalValue.negate();
            }

            // Return int or long if possible, else string for large numbers
            if (decimalValue.bitLength() <= 31) { // fits in Integer
                return decimalValue.intValue();
            } else if (decimalValue.bitLength() <= 63) { // fits in Long
                return decimalValue.longValue();
            } else {
                return decimalValue.toString(); // large number as string to avoid precision loss
            }
        } catch (Exception e) {
            // On invalid input, return null or handle differently
            return null;
        }
    }
}


output:

{
  "a": -1,
  "b": "100000000000000000000000000000000000000000000000000000000000000",
  "c": 0,
  "d": null,
  "e": 15
}

