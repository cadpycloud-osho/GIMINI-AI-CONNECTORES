mapLeafValues:

example 1:
input:

import java.util.*;
import java.util.function.BiFunction;

public class Main {
    
    public static void main(String[] args) {
        Map<String, Object> result = executeMapLeafValuesTest();
        System.out.println(result);
    }
    
    @SuppressWarnings("unchecked")
    public static Map<String, Object> executeMapLeafValuesTest() {
        Map<String, Object> input = Map.of(
            "user", Arrays.asList(
                Map.of(
                    "name", "mariano",
                    "lastName", "achaval"
                )
            ),
            "group", "data-weave"
        );
        
        return (Map<String, Object>) mapLeafValues(input, (value, path) -> {
            if (value instanceof String s) {
                return s.toUpperCase();
            }
            return value;
        });
    }
    
    /**
     * DataWeave Tree.mapLeafValues() equivalent:
     * Recursively maps leaf values while preserving structure
     */
    @SuppressWarnings("unchecked")
    public static Object mapLeafValues(Object input, BiFunction<Object, String, Object> mapper) {
        if (input instanceof Map) {
            Map<String, Object> result = new HashMap<>();
            ((Map<String, Object>) input).forEach((key, value) -> {
                result.put(key, mapLeafValues(value, mapper));
            });
            return result;
        } else if (input instanceof List) {
            List<Object> result = new ArrayList<>();
            ((List<Object>) input).forEach(value -> {
                result.add(mapLeafValues(value, mapper));
            });
            return result;
        } else {
            // Leaf node - apply mapper
            return mapper.apply(input, "");
        }
    }
}



output:
{user=[{name=MARIANO, lastName=ACHAVAL}], group=DATA-WEAVE}



-----------------------------------------------------------------

example 2:



input:

import java.util.*;
import java.util.function.BiFunction;

public class Main {
    
    public static void main(String[] args) {
        Map<String, Object> result = executeMapLeafValuesPathTest();
        System.out.println(result);
    }
    
    @SuppressWarnings("unchecked")
    public static Map<String, Object> executeMapLeafValuesPathTest() {
        // Fix: Use HashMap to avoid Map.of() immutability issues
        Map<String, Object> input = new HashMap<>(Map.of(
            "name", "Mariano",
            "test", Arrays.asList(1, 2, 3)
        ));
        
        return (Map<String, Object>) mapLeafValues(input, Main::pathBasedMapper, "");
    }
    
    /**
     * DataWeave path type logic equivalent:
     * if(isObjectType(path)) "***"
     * else if(isArrayType(path)) "In an array"
     * else "Is an attribute"
     */
    private static String pathBasedMapper(Object value, String path) {
        if (isObjectType(path)) {
            return "***";
        } else if (isArrayType(path)) {
            return "In an array";
        } else {
            return "Is an attribute";
        }
    }
    
    private static boolean isObjectType(String path) {
        // Object type: root level or object property (no array indicators)
        return path == null || path.isEmpty() || !path.contains("[");
    }
    
    private static boolean isArrayType(String path) {
        // Array type: contains array index notation [n]
        return path != null && path.contains("[");
    }
    
    /**
     * DataWeave Tree.mapLeafValues() equivalent with path tracking
     */
    @SuppressWarnings("unchecked")
    public static Object mapLeafValues(Object input, BiFunction<Object, String, Object> mapper, String path) {
        if (input instanceof Map) {
            Map<String, Object> result = new HashMap<>();
            ((Map<String, Object>) input).forEach((key, value) -> {
                String newPath = path.isEmpty() ? key : path + "." + key;
                Object mapped = mapLeafValues(value, mapper, newPath);
                if (mapped != null) {
                    result.put(key, mapped);
                }
            });
            return result.isEmpty() ? null : result;
        } else if (input instanceof List) {
            List<Object> result = new ArrayList<>();
            for (int i = 0; i < ((List<?>) input).size(); i++) {
                String newPath = path.isEmpty() ? "[" + i + "]" : path + "[" + i + "]";
                result.add(mapLeafValues(((List<?>) input).get(i), mapper, newPath));
            }
            return result;
        } else {
            // Leaf node - apply mapper with current path
            return mapper.apply(input, path);
        }
    }
}



output:

{name=***, test=[In an array, In an array, In an array]}



