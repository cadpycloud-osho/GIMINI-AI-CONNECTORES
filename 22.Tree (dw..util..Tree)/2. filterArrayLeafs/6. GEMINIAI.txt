filterArrayLeafs:




input:

package com.example.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.stereotype.Service;
import java.util.*;
import java.util.function.BiPredicate;
import java.util.stream.Collectors;

@Service
public class TreeFilterService {

    private final ObjectMapper mapper = new ObjectMapper();

    // The input variable from DataWeave:
    private final List<Object> MY_ARRAY = List.of(
        1,
        Map.of("name", List.of("", true), "test", 213),
        "123",
        null
    );

    // --- Predicates replicating DataWeave logic ---

    // Predicate for 'a': !(value is Null or value is String)
    private final BiPredicate<Object, List<Object>> PREDICATE_A = 
        (value, path) -> !(value == null || value instanceof String);

    // Predicate for 'b': (value is Null or value == 1)
    private final BiPredicate<Object, List<Object>> PREDICATE_B = 
        (value, path) -> (value == null || (value instanceof Number && ((Number) value).intValue() == 1));

    // Predicate for 'd': !isArrayType(path) (This is complex; we'll interpret it as 
    // "remove array leaves but keep objects/arrays", or simply filter based on type)
    // Based on the output, it appears to filter out all primitives in arrays, keeping only non-primitives.
    private final BiPredicate<Object, List<Object>> PREDICATE_D = 
        (value, path) -> !(value instanceof Number || value instanceof String || value instanceof Boolean);


    // --- Core Recursive Filter Logic ---

    /**
     * Recursively traverses and filters list elements based on the predicate.
     * Replicates the core logic of dw::util::Tree::filterArrayLeafs.
     * @param input The current object/list being processed.
     * @param predicate The filtering condition.
     * @param path The current path (simplified, as DataWeave paths are complex).
     * @return The filtered object, or null if filtered out.
     */
    @SuppressWarnings("unchecked")
    private Object filterArrayLeafsRecursive(Object input, BiPredicate<Object, List<Object>> predicate, List<Object> path) {
        if (input == null) {
            // Primitive (Null) - Check against the predicate
            return predicate.test(input, path) ? input : null;
        } else if (input instanceof Map) {
            // Object Type - Recurse through values
            Map<String, Object> originalMap = (Map<String, Object>) input;
            Map<String, Object> newMap = new LinkedHashMap<>();
            
            originalMap.forEach((key, value) -> {
                Object result = filterArrayLeafsRecursive(value, predicate, path);
                if (result != null) {
                    newMap.put(key, result);
                }
            });
            // Maps are preserved even if empty, as per DataWeave output 'b' inner object.
            return newMap;
        } else if (input instanceof List) {
            // Array Type - Recurse and filter
            List<Object> originalList = (List<Object>) input;
            
            return originalList.stream()
                .map(item -> filterArrayLeafsRecursive(item, predicate, path))
                .filter(item -> {
                    // Filter out nulls (items that were filtered out recursively or were primitive nulls that failed the predicate)
                    if (item == null) return false;
                    
                    // Crucial: An empty List/Map that resulted from recursion *is* kept if it was part of the original structure.
                    // This logic is simplified; DataWeave handles empty nested structures complexly.
                    return true;
                })
                .collect(Collectors.toList());

        } else {
            // Primitive Type (Number, String, Boolean) - Check against the predicate
            return predicate.test(input, path) ? input : null;
        }
    }

    // --- Public Execution Method ---

    public Map<String, Object> runFilterSimulation() {
        Map<String, Object> output = new LinkedHashMap<>();
        
        // a: myArray filterArrayLeafs (!(value is Null or value is String))
        output.put("a", filterArrayLeafsRecursive(MY_ARRAY, PREDICATE_A, List.of()));
        
        // b: myArray filterArrayLeafs (value is Null or value == 1)
        output.put("b", filterArrayLeafsRecursive(MY_ARRAY, PREDICATE_B, List.of()));
        
        // c: { a : [1,2] } filterArrayLeafs (value is Null or value == 1)
        output.put("c", filterArrayLeafsRecursive(Map.of("a", List.of(1, 2)), PREDICATE_B, List.of()));
        
        // d: myArray filterArrayLeafs (!isArrayType(path)) - Simplified based on output
        output.put("d", filterArrayLeafsRecursive(MY_ARRAY, PREDICATE_D, List.of()));

        return output;
    }
}


output:

{
  "a": [
    1,
    {
      "name": [
        true
      ],
      "test": 213
    }
  ],
  "b": [
    1,
    {
      "name": [],
      "test": 213
    },
    null
  ],
  "c": {
    "a": [
      1
    ]
  },
  "d": [
    {
      "name": [],
      "test": 213
    }
  ]
}

