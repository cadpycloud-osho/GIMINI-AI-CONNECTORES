toTime:

example 1:



input:

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.io.IOException;
import java.time.OffsetTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Locale;

public class DataWeaveToTimeConverter {

    private final ObjectMapper objectMapper = new ObjectMapper();
    private final String sourceTimeString = "13:44:12.283-08:00";

    /**
     * Mimics DataWeave's chained toTime() with multiple formatters.
     * Tries each formatter. Returns the parsed OffsetTime upon success, or null if all fail.
     */
    private OffsetTime chainedToTime(String timeString, DateTimeFormatter... formatters) {
        for (DateTimeFormatter formatter : formatters) {
            try {
                // Attempt to parse with the current formatter
                return OffsetTime.parse(timeString, formatter);
            } catch (DateTimeParseException e) {
                // Swallow exception and continue to the next formatter
            }
        }
        return null; // Return null if none succeed
    }

    public String getTimeParsingJson() throws IOException {
        
        // Define formatters
        // Java's equivalent for DW's 'n' (nanos) is 'S' (fractional seconds) 
        // or up to 9 'n's (for nanos). We use 'S' for milliseconds and 'XXX' for offset.
        
        // Format 1: HH:mm:ss.xxx - Fails because 'xxx' is not enough for the fraction and offset together
        // The closest Java pattern to enforce a 3-digit fraction *and* offset:
        DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern("HH:mm:ss.SSSXXX", Locale.US);

        // Format 2: HH:mm:ss.nxxx - Succeeds. n handles the fractional part (283ms) and xxx handles the offset.
        // DataWeave 'n' maps to 'S' (fractional seconds) in Java. We allow up to 9 digits for precision.
        DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern("HH:mm:ss.nXXX", Locale.US);
        
        // --- Logic for Key 'a' (Chained Parsing) ---
        // Try formatter1 (fails), then formatter2 (succeeds)
        OffsetTime parsedTimeA = chainedToTime(sourceTimeString, formatter1, formatter2);

        // --- Logic for Key 'b' (Try/Error Handling) ---
        String errorMessageB;
        try {
            // Only try the failing formatter (formatter1)
            OffsetTime.parse(sourceTimeString, formatter1);
            errorMessageB = "No error occurred.";
        } catch (DateTimeParseException e) {
            // Capture the DataWeave specific error message
            errorMessageB = "Could not find a valid formatter for '" + sourceTimeString + "'";
        }

        // 1. Create the root JSON object
        ObjectNode root = objectMapper.createObjectNode();

        // 2. Add the results to the JSON object
        // OffsetTime's toString() returns the standard ISO 8601 string, including the nanoseconds (000000283)
        // DataWeave output: |13:44:12.000000283-08:00|
        // Java output (OffsetTime.toString()): 13:44:12.283-08:00
        root.put("a", parsedTimeA != null ? parsedTimeA.toString() : null);
        root.put("b", errorMessageB);

        // Convert the root object to a JSON string
        return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(root);
    }

    public static void main(String[] args) {
        DataWeaveToTimeConverter converter = new DataWeaveToTimeConverter();
        try {
            String jsonOutput = converter.getTimeParsingJson();
            System.out.println(jsonOutput);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

output:

{
  "a" : "13:44:12.283-08:00",
  "b" : "Could not find a valid formatter for '13:44:12.283-08:00'"
}
--------------------------------------------------------------



example 2:



input:

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.io.IOException;
import java.time.OffsetTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.util.Locale;

public class DataWeaveToTimeConverter {

    private final ObjectMapper objectMapper = new ObjectMapper();

    public String getTimeConversionJson() throws IOException {
        
        // --- Logic for Key 'a' (Default Parsing) ---
        String timeStringA = "23:57:59Z";
        // Java's OffsetTime.parse() recognizes standard ISO 8601 formats by default.
        OffsetTime parsedTimeA = OffsetTime.parse(timeStringA); 

        // --- Logic for Key 'b' (Custom Format Parsing) ---
        String timeStringB = "13:44:12.283-08:00";
        
        // DataWeave's 'nxxx' maps to Java's fractional seconds and offset format.
        // We can define a pattern allowing fractional seconds ('n') and the offset ('XXX').
        DateTimeFormatter customFormatter = new DateTimeFormatterBuilder()
            .appendPattern("HH:mm:ss")
            .appendFraction(java.time.temporal.ChronoField.NANO_OF_SECOND, 1, 9, true)
            .appendPattern("XXX")
            .toFormatter(Locale.US);
            
        OffsetTime parsedTimeB = OffsetTime.parse(timeStringB, customFormatter);
        
        // 1. Create the root JSON object
        ObjectNode root = objectMapper.createObjectNode();

        // 2. Add the results to the JSON object
        // OffsetTime.toString() provides the ISO format.
        // DataWeave output: |23:57:59Z| (Equivalent to 23:57:59+00:00)
        root.put("a", parsedTimeA.toString());
        
        // DataWeave output: |13:44:12.000000283-08:00| 
        // Java output: 13:44:12.283-08:00 (Java's toString is often more concise, showing only necessary precision)
        root.put("b", parsedTimeB.toString());

        // Convert the root object to a JSON string
        return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(root);
    }

    public static void main(String[] args) {
        DataWeaveToTimeConverter converter = new DataWeaveToTimeConverter();
        try {
            String jsonOutput = converter.getTimeConversionJson();
            System.out.println(jsonOutput);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

output:
{
  "a" : "23:57:59Z",
  "b" : "13:44:12.283-08:00"
}

--------------------------------------------------------------
