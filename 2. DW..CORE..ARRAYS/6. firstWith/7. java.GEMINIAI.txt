firstWith:



input:

public class Main {
    private String name;
    private String lastName;

    // Constructor name must match the class name: Main
    public Main(String name, String lastName) {
        this.name = name;
        this.lastName = lastName;
    }

    public String getName() {
        return name;
    }

    // toString method for easy printing of the result object
    @Override
    public String toString() {
        // Formats the output to look like a JSON object
        return "{\n    \"name\": \"" + name + "\",\n    \"lastName\": \"" + lastName + "\"\n}";
    }

    // The main method to demonstrate class usage
    public static void main(String[] args) {
        // Example instance of the Main class
        Main userA = new Main("Mariano", "Achaval");
        
        // Printing the object using the overridden toString() method
        System.out.println("Printing User A:");
        System.out.println(userA);
        
        // This output is based on the data in the Main class instance.
        // It does NOT match your requested output structure, which seems to imply
        // another DataWeave-like operation (like mapping an array).
        
        // If your goal was to produce the exact JSON output:
        System.out.println("\n-- Requested Output Structure --");
        System.out.println("{\n  \"a\": " + userA + ",\n  \"b\": null\n}");
    }
}


output:
Output structure:
{
  "a": {
    "name": "Mariano",
    "lastName": "Achaval"
  },
  "b": null
}













1. Java Code (Using Streams for Functional Style)
The Java Stream API's filter() combined with findFirst() perfectly implements the firstWith functionality with built-in short-circuiting.

Java

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;

public class DataWeaveFirstWithStream {

    // Helper method to mimic DataWeave 'firstWith' using Streams
    public static <T> T firstWith(List<T> list, Predicate<T> condition) {
        // filter() applies the condition, and findFirst() returns the first match, 
        // short-circuiting the stream. orElse(null) handles the case where no match is found.
        return list.stream()
                   .filter(condition)
                   .findFirst()
                   .orElse(null);
    }

    public static void main(String[] args) {
        // Source data array (DataWeave 'users' variable)
        List<User> users = Arrays.asList(
            new User("Mariano", "Achaval"), 
            new User("Ana", "Felisatti"), 
            new User("Mariano", "de Sousa")
        );

        // Scenario A: users firstWith ((user, index) -> user.name == "Mariano")
        User resultA = firstWith(users, user -> user.getName().equals("Mariano"));

        // Scenario B: users firstWith ((user, index) -> user.name == "Peter")
        User resultB = firstWith(users, user -> user.getName().equals("Peter"));

        // Print the final JSON-like output structure
        System.out.println("Output structure:");
        System.out.println("{");
        System.out.println("  \"a\": " + resultA + ",");
        System.out.println("  \"b\": " + resultB);
        System.out.println("}");
    }
}
2. Java Code (Using an Imperative Loop)
This traditional approach uses a for loop, explicitly implementing the short-circuiting by returning immediately upon finding the first match.

Java

import java.util.Arrays;
import java.util.List;

public class DataWeaveFirstWithImperative {

    // Helper method to mimic DataWeave 'firstWith' using an imperative loop
    // Since we don't use the index, we can simplify the search predicate.
    public static User firstWith(List<User> list, String searchName) {
        for (User user : list) {
            if (user.getName().equals(searchName)) {
                return user; // Short-circuit: return the first match immediately
            }
        }
        return null; // Return null if the loop finishes without finding a match
    }

    public static void main(String[] args) {
        // Source data array (DataWeave 'users' variable)
        List<User> users = Arrays.asList(
            new User("Mariano", "Achaval"), 
            new User("Ana", "Felisatti"), 
            new User("Mariano", "de Sousa")
        );

        // Scenario A: users firstWith ((user, index) -> user.name == "Mariano")
        User resultA = firstWith(users, "Mariano");

        // Scenario B: users firstWith ((user, index) -> user.name == "Peter")
        User resultB = firstWith(users, "Peter");

        // Print the final JSON-like output structure
        System.out.println("Output structure:");
        System.out.println("{");
        System.out.println("  \"a\": " + resultA + ",");
        System.out.println("  \"b\": " + resultB);
        System.out.println("}");
    }
}
Java Output
The output from both Java implementations is consistent with the DataWeave result:

JSON

Output structure:
{
  "a": {
    "name": "Mariano",
    "lastName": "Achaval"
  },
  "b": null
}